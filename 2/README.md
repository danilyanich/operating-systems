# Вариант 3 #
### Краткое описание задачи. ###
Написать программу, копирующую файл. Программа должна запускать два дочерних процесса, один читает файл, другой пишет. Передача данных между процессами должна быть реализована через общую область памяти, синхронизация – с помощью объектов ядра. Материнский процесс должен обрабатывать ошибки в дочерних процессах (например, если при записи произошла ошибка – читающий процесс должен завершаться материнским).

### Описание методов, которые был использованы для решения задачи. ###
***CreateEvent(NULL, FALSE, TRUE, readEventName)*** – создание события чтения.  
***CreateEvent(NULL, TRUE, TRUE, writeEventName)*** – создание события записи.  
***CreateEvent(NULL,TRUE,FALSE, closeEventName)*** – создание события закрытия.  
***OpenEvent(EVENT_ALL_ACCESS, FALSE, readEventName)*** – получение доступа к событию чтения.  
***OpenEvent(EVENT_ALL_ACCESS, FALSE, writeEventName)*** – получение доступа к событию записи.  
***CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,BUFF_SIZE, name)*** –  создание объекта отображенного в памяти(проецируемого) файла для заданного файла.  
***MapViewOfFile(fileMap,FILE_MAP_ALL_ACCESS,0,0,BUFF_SIZE)*** – отображает представление проецируемого файла в адресное пространство процессов чтения и записи.  
***CreateProcess(p1, (LPWSTR)"path_from", NULL, NULL, FALSE, 0, NULL, NULL, &si1, &pi1)*** – создаем процесс чтения и его первичный поток.  
***CreateProcess(p2, (LPWSTR)"path_to", NULL, NULL, FALSE, 0, NULL, NULL, &si2, &pi2)*** – создаем процесс записи и его первичный поток.  

***WaitForSingleObject(pi1.hProcess, INFINITE)*** – останавливаем выполнение программы, до тех пор пока процесс чтения не окажется в сигнальном состоянии.  
***OpenFileMapping(FILE_MAP_ALL_ACCESS,FALSE,(LPWSTR)"path_from.")*** – открываем объект проецируемого исходного файла.  
***WaitForSingleObject(readEvent, INFINITE)*** – останавливаем выполнение процесса чтения, пока не закончится процесс записи.  
***CopyMemory((PVOID)pBuf, (TCHAR*)a, (BUFF_SIZE * TCHAR_SIZE)*** – копируем блок памяти длины BUFF_SIZE из исходного файла в переменную а.  
***ResetEvent(readEvent)*** – переводим событие чтения в занятое состояние.  
***SetEvent(writeEvent)*** – переводим событие записи в сигнальное состояние.  
***ResetEvent(closeEvent)*** – переводим событие закрытия в занятое есостояние.  

***WaitForSingleObject(pi2.hProcess, INFINITE)*** – останавливаем выполнение программы, до тех пор пока процесс записи не окажется в сигнальном состоянии.  
***OpenFileMapping(FILE_MAP_ALL_ACCESS,FALSE,(LPWSTR)"path_to.")*** – открываем объект проецируемого нового файла.  
***WaitForSingleObject(writeEvent, INFINITE)*** – останавливаем выполнение процесса записи, пока не закончится процесс чтения.  
***CopyMemory(x, pBuf, (_tcslen(pBuf) * sizeof(TCHAR)))*** – копируем блок памяти длины BUFF_SIZE из буфера в переменную х.  
***ResetEvent(writeEvent)*** – переводим событие записи в занятое состояние.  
***SetEvent(readEvent)*** – переводим событие чтение в сигнальное состояние.  
***fout.write((char*)x, BUFF_SIZE)*** – записываем в файл блок памяти длиной BUFF_SIZE  
***ResetEvent(closeEvent)*** – переводим событие закрытия в занятое состояние.  
***CloseHandle(pi1.hThread)*** – закрывает дескриптор процесса чтения.  
***CloseHandle(pi2.hThread)*** – закрывает дескриптор процесса записи.  
***CloseHandle(closeEvent)*** – закрывает дескриптор события закрытия.  
***CloseHandle(readEvent)*** – закрывает дескриптор события чтения.  
***CloseHandle(writeEvent)*** – закрывает дексриптор события записи.  
***UnmapViewOfFile(pBuf)*** – отменяет отображение представления файла из адресного пространства процессов чтения и записи.  
***CloseHandle(fileMap)*** – закрывает проекцию файла.  

### Обосновать необходимость использования конкретного объекта синхронизации для решения вашей задачи. ###
Для синхронизации процессов чтения из и записи в общую память использовались два события с ручным сбросом: один для процесса записи в общую память, второй – для чтения из неё. 
Данный метод синхронизации был выбран в связи с тем, что он может обеспечить согласованную работу и упорядоченный доступ двух процессов к разделяемому ресурсу, поскольку запись и чтение происходят поочередно и по частям. 


# Контрольные вопросы #
1. Поясните, в чем состоит проблема синхронизации процессов/потоков?
2. Что такое “эффект гонок”?
3. Что такое клинч?
4. Что такое взаимоисключение?
5. Что такое критическая секция с точки зрения теории операционных систем?
6. Что такое объект ядра? Какие объекты ядра операционной системы windows или Linux вы знаете?
7. Какие есть подходы к предотвращению, последствий тупиков?
8. Как можно диагностировать наличие в системе большой очереди процессов или тупика? В чем различие этих ситуаций?
9. Чем объект синхронизации критическая секция отличается от объекта синхронизации семафор в операционной системе windows.
10. Что такое файлы, проецируемые в память? Какие базовые механизмы операционных систем реализованы через данный подход?
    
## Ответы на контрольные вопросы ##
1. Процессам часто нужно взаимодействовать друг с другом, например, один процесс может передавать данные другому процессу, или несколько процессов могут обрабатывать данные из общего файла. Во всех этих случаях возникает проблема синхронизации процессов, которая может решаться приостановкой и активизацией процессов, организацией очередей, блокированием и освобождением ресурсов.
2. Эффект гонок – ситуация, когда два или более процессов обрабатывают разделяемые данные, и конечный результат зависит от соотношения скорости выполнения процессов
3. Клинч – взаимная блокировка. Возникает, когда при некоторых условиях процессы взаимно блокируют друг друга
4. Взаимоисключение - обеспечение, чтобы в каждый момент в критической секции, связанной с одним ресурсом, находился максимум один процесс. 
5. Критическая секция - это часть программы, в которой осуществляется доступ к разделяемым данным. Чтобы исключить эффект гонок по отношению к некоторому ресурсу, необходимо обеспечить, чтобы в каждый момент в критической секции, связанной с этим ресурсом, находился максимум один процесс. 
6. Каждый объект ядра — на самом деле просто блок памяти, выделенный ядром и доступный только ему. Этот блок представляет собой структуру данных, в элементах которой содержится информация об объекте.
Некоторые элементы (дескриптор защиты, счетчик числа пользователей и др.) присутствуют во всех объектах, но большая их часть специфична для объектов конкретного типа. 
Система позволяет создавать и оперировать несколькими типами таких объектов, в том числе: маркерами доступа (access token objects), файлами (file objects), проекциями файлов (file-mapping objects), портами завершения ввода вывода (I/O completion port objects), заданиями (jobs), почтовыми ящиками (mailslot objects), мьютексами (mutex objects), каналами (pipe objects), процессами (thread objects) и ожидаемыми таймерами (waitable timer objects). Windows – fileMapping
7. Тупики могут быть предотвращены на стадии написания программ, то есть программы должны быть написаны таким образом, чтобы тупик не мог возникнуть ни при каком соотношении взаимных скоростей процессов. Второй подход к предотвращению тупиков называется динамическим и заключается в использовании определенных правил при назначении ресурсов процессам, например, ресурсы могут выделяться в определенной последовательности, общей для всех процессов.
В некоторых случаях, когда тупиковая ситуация образована многими процессами, использующими много ресурсов, распознавание тупика является нетривиальной задачей. Существуют формальные, программно-реализованные методы распознавания тупиков, основанные на ведении таблиц распределения ресурсов и таблиц запросов к занятым ресурсам. Анализ этих таблиц позволяет обнаружить взаимные блокировки.
Если же тупиковая ситуация возникла, то не обязательно снимать с выполнения все заблокированные процессы. Можно снять только часть из них, при этом освобождаются ресурсы, ожидаемые остальными процессами, можно вернуть некоторые процессы в область свопинга, можно совершить "откат" некоторых процессов до так называемой контрольной точки, в которой запоминается вся информация, необходимая для восстановления выполнения программы с данного места. Контрольные точки расставляются в программе в местах, после которых возможно возникновение тупика.
8. Очередь – явление, демонстрирующее высокий коэффициент использования ресурсов. Тупики же являются неразрешимой ситуацией
9. Критическая секция может быть реализована двумя способами: с использованием системных функций или блокирующих переменных. Процесс опасен: если происходит крах в критической секции, то происходит крах в ОС. Для каждого выделяемого ресурса есть два состояния: 0 и 1. Недостаток КС: бесконечный цикл (всегда будет 1 процесс, который будет выполнять рутинное действие по опросу блокирующей переменной, бесполезно тратящей процессорное время). Семафор – есть два примитива: один увеличивает переменную S на 1, при этом доступ к переменной ограничен для других процессов, второй уменьшает значение переменной S на 1 в случае, если это возможно. Если S=0, то невозможно уменьшить S и остаться в области целых неотрицательных значений, в этом случае процесс, вызывающий P-операцию, ждет, пока это уменьшение станет возможным. Успешная проверка и уменьшение также является неделимой операцией.
10. Отображение файла в память (на память) — это способ работы с файлами в некоторых операционных системах, при котором всему файлу или некоторой непрерывной его части ставится в соответствие определённый участок памяти (диапазон адресов оперативной памяти). При этом чтение данных из этих адресов фактически приводит к чтению данных из отображенного файла, а запись данных по этим адресам приводит к записи этих данных в файл. Отображать на память часто можно не только обычные файлы, но и файлы устройств.
